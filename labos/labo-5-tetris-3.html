<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Labo 5 - Tetris 3</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <main>
<header id="title-block-header">
    <nav>
        <a href="/"><i class="fa fa-angle-left"></i> Back</a>
      </nav>
<h1 class="title">Labo 5 - Tetris 3</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#informations-générales"
id="toc-informations-générales">Informations Générales</a></li>
<li><a href="#lien-avec-le-précédent-labo"
id="toc-lien-avec-le-précédent-labo">Lien avec le précédent
labo</a></li>
<li><a href="#ajouts-de-ce-labo" id="toc-ajouts-de-ce-labo">Ajouts de ce
labo</a>
<ul>
<li><a href="#scores" id="toc-scores">Scores</a>
<ul>
<li><a href="#calcul" id="toc-calcul">Calcul</a></li>
<li><a href="#affichage" id="toc-affichage">Affichage</a></li>
</ul></li>
<li><a href="#multijoueur" id="toc-multijoueur">Multijoueur</a>
<ul>
<li><a href="#réplique-client" id="toc-réplique-client">Réplique
client</a></li>
<li><a href="#communications-par-websocket"
id="toc-communications-par-websocket">Communications par
websocket</a></li>
<li><a href="#messages" id="toc-messages">Messages</a></li>
<li><a href="#affichage-1" id="toc-affichage-1">Affichage</a></li>
</ul></li>
<li><a href="#game-over" id="toc-game-over">Game Over</a></li>
<li><a href="#tests" id="toc-tests">Tests</a></li>
</ul></li>
<li><a href="#installation-et-lancement"
id="toc-installation-et-lancement">Installation et lancement</a></li>
<li><a href="#travail-à-réaliser" id="toc-travail-à-réaliser">Travail à
réaliser</a></li>
</ul>
</nav>
<!-- # Changelog

| Date  | Changement                                                                                                          |
| ----- | ------------------------------------------------------------------------------------------------------------------- |
| 02.11 | Précisions sur comportement lorsqu'un player quitte la partie, [ici](#change_remove_player), [ici](#change_remove_player2), et [là](#change_remove_player3).                         |
| 04.11 | Extension de deadline : 14 Novembre |
 -->
<h1 id="informations-générales">Informations Générales</h1>
<ul>
<li><strong>Date du rendu :</strong> Mardi 14 Novembre, 13:15 CEST</li>
<li><strong>Groupes</strong> : À réaliser seul ou à deux, en reprenant
de préférence les groupes du labo 1.</li>
<li><strong>Plagiat</strong> : En cas de copie manifeste, vous y serez
confrontés, vous obtiendrez la note de 1, et l’incident sera reporté au
responsable de la filière, avec un risque d’échec critique immédiat au
cours. Ne trichez pas. <em>(Notez que les IAs génératives se trouvent
aujourd’hui dans une zone qui est encore juridiquement floue pour ce qui
est du plagiat, mais des arguments se valent à en considérer
l’utilisation comme tel. Quoi qu’il en soit, nous vous proposons une
autre vision sur la question : votre ambition est d’apprendre et
d’acquérir des compétences, et votre utilisation éventuelle de cet outil
doit refléter ceci. Tout comme Stackoverflow peut être à la fois un
outil d’enrichissement et une banque de copy-paste, faites un choix
intentionnel et réfléchi, vos propres intérêts en tête, de l’outil que
vous ferez de l’IA générative)</em></li>
</ul>
<h1 id="lien-avec-le-précédent-labo">Lien avec le précédent labo</h1>
<p>Ce labo est une suite du second labo sur Tetris. Toutes les
informations données dans <a href="./labo-3-tetris-2.md">l’énoncé du
précédent labo</a> restent donc valables pour celui-ci.</p>
<p>Au moment de rejoindre ce nouvel assignment sur Github Classroom, un
nouveau repo sera créé. Vous êtes libres de reprendre, ou non, les
équipes du labo précédent. Ce nouveau repo vous donne comme point de
départ la correction du labo précédent et y ajoute les TODOs de ce
labo-ci. Si vous souhaitez réutiliser votre code du premier labo au lieu
de celui fourni, vous pouvez le faire en exécutant les commandes
suivantes :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> remote add lab2 <span class="op">&lt;</span>tetris2-repo-url<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> fetch <span class="at">--all</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> merge <span class="at">-e</span> lab2/main <span class="at">--allow-unrelated-histories</span></span></code></pre></div>
<p>Dans ce cas, nous vous demandons de préciser le nom de l’équipe dont
vous avez repris le code dans le README. Au moins une personne de la
nouvelle équipe doit avoir été membre de l’équipe dont le code a été
repris.</p>
<p>Une fois les conflits du merge résolus, vous aurez donc votre
solution au précédent labo avec les ajouts que nous vous fournissons
pour celui-ci. Vérifiez tout de même de ne pas avoir supprimé de tests
ou de TODOs par erreur durant le merge.</p>
<h1 id="ajouts-de-ce-labo">Ajouts de ce labo</h1>
<p>Ce labo complète les fonctionnalités du jeu. Vous aurez donc, à la
fin de celui-ci, un Tetris multijoueur fonctionnel. Ces dernières
fonctionnalités, et les tâches qui vous sont demandées, sont décrites
ici.</p>
<h2 id="scores">Scores</h2>
<h3 id="calcul">Calcul</h3>
<p>Nous introduisons le concept de score. Chaque joueur ou joueuse
obtient un score qui permettra de déterminer qui a gagné au moment du
game over. Pour un joueur ou une joueuse donnée, son score est composé
de deux parties : - le nombre de lignes qu’il ou elle a fait
disparaître, multiplié par la constante <code>scorePerLine</code>
(définie dans <code>constants.js</code>), et - un malus correspondant au
nombre de blocs lui appartenant encore présents sur la carte de jeu.</p>
<p>Si j’ai fait disparaître 5 lignes sur toute la durée de la partie, et
que, au moment où le jeu ne peut plus avancer et que la partie doit donc
se terminer, il reste 13 blocs de ma couleur sur la carte, mon score
sera donc de <span
class="math inline">5 * <code>scorePerLine</code> − 13</span>, donc
<span class="math inline">37</span> si <code>scorePerLine</code> vaut
10.</p>
<p>Il vous est donc demandé de compléter les fonctions
<code>getBlocksPerPlayer</code> dans <code>gameMap.js</code>, et
<code>getTotalScores</code> dans <code>game.js</code>, qui seront
utilisées pour calculer les scores totaux quand nécessaire. La classe
<code>PlayerInfo</code> a aussi été complétée par une propriété
<code>clearedLines</code> que vous devrez maintenir à jour tout au long
du jeu, et utiliser dans votre calcul des scores.</p>
<p>Notez qu’il sera possible pour un joueur ou une joueuse de quitter la
partie en cours. Dans ce cas, les blocs lui appartenant sur la carte y
restent, et son score ne se calcule alors plus qu’à travers le nombre de
blocs lui appartenant sur la carte. Si le player de l’exemple ci-dessus
quitte la partie, son score vaudra donc <span
class="math inline"> − 13</span>.</p>
<h3 id="affichage">Affichage</h3>
<p>Il est demandé que l’état actuel des scores soit affiché par chaque
client à côté du canvas. Nous vous fournissons dans les fichiers
<code>index.html</code> et <code>style.css</code> un point de départ
pour cela, que vous pouvez bien entendu modifier et compléter pour
obtenir l’affichage que vous souhaitez. Les seules contraintes sont que
les scores de chaque joueur ou joueuse doivent être affichés clairement
et avec leur id (par exemple
<code>Player &lt;id&gt; : &lt;score&gt;</code>), et dans un ordre
décroissant, du plus haut score au plus bas.</p>
<p>Notez que nous avons décidé de continuer d’afficher le score des
joueurs et joueuses qui ont quitté la partie.</p>
<p>La mise à jour des scores affichés sera la responsabilité de
<code>Renderer</code>. Il vous revient d’implémenter la méthode
<code>updateScores</code> dans ce but, et de l’appeler correctement afin
que les scores affichés soient toujours à jour.</p>
<h2 id="multijoueur">Multijoueur</h2>
<h3 id="réplique-client">Réplique client</h3>
<p>Jusqu’à maintenant, la logique du jeu était exécutée sur le client
lui-même. Puisque nous voulons maintenant permettre la coexistence de
plusieurs clients sur la même partie, nous choisissons de déplacer cette
gestion sur le serveur. Les clients ne seront alors responsables que de
l’affichage du jeu, et de l’envoi des interactions de l’utilisateur au
serveur. Le serveur, lui, devra réagir à ces interactions et faire
évoluer la partie correctement, puis partager toute évolution aux
clients pour leur permettre un affichage à jour et synchronisé du
jeu.</p>
<p>Dans ce but, nous avons apporté des modifications au fichier
<code>game.js</code>. Il existe maintenant une classe parente appelée
<code>DrawableGame</code> qui offre les quelques méthodes et propriétés
requises par le renderer pour l’afficher. La classe <code>Game</code>
hérite donc de <code>DrawableGame</code>, et implémente les méthodes
additionnelles spécifiques à la gestion du jeu. Une nouvelle classe
<code>Replica</code> hérite également de <code>DrawableGame</code>, et
ne fait que se maintenir à jour avec une instance de <code>Game</code>
qui l’informe de ses évolutions à travers des messages que nous
décrivons plus loin. Elle n’est donc responsable d’aucune logique, mais
uniquement du maintien synchronisé de ses données.</p>
<p>Notez que, si un client quitte la partie en cours de route, toutes
les répliques restantes en seront informées par le serveur, et le
<code>PlayerInfo</code> correspondant doit être retiré de toutes les
répliques (ainsi que de l’instance de <code>Game</code>, bien entendu).
En revanche, il est attendu que le serveur ne réutilise pas cet id pour
un futur player, afin d’éviter toute confusion.</p>
<h3 id="communications-par-websocket">Communications par websocket</h3>
<p>Suite au cours sur la programmation réseau, il doit vous paraitre
judicieux d’utiliser le protocole websocket pour permettre la
communication entre le serveur et le client, puisqu’il permet à chacun
de contacter l’autre sans nécessité de polling (sondage).</p>
<p>Il vous est donc demandé de compléter les fichiers
<code>server.js</code> et <code>app.js</code> pour mettre en place une
connexion websocket pour chaque nouveau client. Lorsqu’un nouveau client
se connecte, le serveur doit lui créer un nouveau player et l’inclure
dans le jeu. À cette fin, une méthode <code>introduceNewPlayer</code>
est à compléter dans <code>Game</code>. De manière similaire, lorsqu’une
connexion websocket est fermée par le client, alors il faut retirer le
player correspondant du jeu. La méthode <code>quit</code> de
<code>Game</code> a cette responsabilité et est à compléter.</p>
<p>Durant l’execution d’une partie, le client devra envoyer tout message
généré par les input listeners au serveur, que la méthode
<code>onMessage</code> gérera. Inversement, à chaque fois que
nécessaire, le serveur enverra des messages à tous les clients connectés
les informant des évolutions du jeu nécessitant une mise à jour de
l’affichage. Ces messages seront alors gérés par la méthode
<code>onMessage</code> de <code>Replica</code>. Afin de permettre
l’envoi de messages de la part du serveur, la classe <code>Game</code>
prend maintenant un argument supplémentaire, <code>messageSender</code>,
représentant une fonction qui, lorsque appelée, enverra son premier
argument, supposé être un message, à tous les clients actuellement
connectés. Il s’agit donc simplement, en d’autres termes, d’un
broadcaster passé à <code>Game</code> au moment de sa construction.</p>
<p>Pour finir, lorsqu’une partie se termine, le serveur doit fermer
toutes les connections actuellement ouvertes et immédiatement démarrer
une nouvelle partie. Les clients devront donc recharger la page s’ils
veulent la rejoindre. Pour permettre ceci, la classe <code>Game</code>
prend un autre nouvel argument, <code>onGameOver</code>, qui est un
callback devant être appelé par <code>Game</code> au moment d’un game
over. Il pourra ainsi être utilisé pour réinitialiser les connections
actuelles en fin de partie.</p>
<h3 id="messages">Messages</h3>
<p>Un certain nombre de messages ont été ajoutés pour permettre au
serveur de communiquer les évolutions de la partie aux clients. Nous
listons ici les classes correspondantes à compléter dans
<code>messages.js</code>, qui héritent toutes de
<code>Message</code>.</p>
<ul>
<li><code>SetPlayerMessage</code> permet l’envoi d’un
<code>PlayerInfo</code> au client. À chaque modification d’informations
liées à un joueur, ou à l’apparition d’un nouveau joueur, ce message
devra être envoyé aux clients avec la nouvelle valeur de
<code>PlayerInfo</code> associée. Notez qu’il ne s’agit pas de
l’approche la plus efficace en termes de couts de communication, puisque
cela implique d’envoyer l’intégralité de la classe
<code>PlayerInfo</code> aux clients même si l’évolution ne concerne que
la position de sa shape, ou bien le nombre de lignes complétées, mais
nous avons fait ce choix dans un but de simplicité
d’implémentation.</li>
<li><code>RemovePlayerMessage</code> informe un client de la suppression
d’un joueur, ce qui peut arriver lorsqu’un client ferme sa connexion au
serveur.</li>
<li><code>UpdateMapMessage</code> permet l’envoi d’une
<code>GameMap</code> au client. À chaque modification de la game map,
par exemple lorsqu’une pièce est “dropped”, un tel message devra être
envoyé aux clients pour les informer du nouvel état de la carte.</li>
<li><code>GameOverMessage</code> notifie le client que le jeu est
terminé.</li>
<li><code>JoinMessage</code> doit être envoyé à chaque nouveau client au
moment où il rejoint le jeu. Ce message contient l’id du player qui lui
a été associé. Notez que ce message ne doit pas être broadcasté à tous
les clients connectés, mais envoyé directement et uniquement au client
rejoignant la partie.</li>
</ul>
<p>Afin de pouvoir envoyer ces messages à travers le réseau, il sera
nécessaire de les encoder et les décoder. Nous choisissons le format
JSON pour cela, et vous demandons de compléter la classe
<code>MessageCodec</code> qui en est responsable. Elle offre deux
méthodes statiques : - <code>encode</code> qui prend un message et
l’encode en une chaine de caractères respectant le format JSON, et -
<code>decode</code> qui prend une chaine de caractères respectant le
format JSON et le décode en une instance de message.</p>
<p>Notez que <code>decode</code> produit bien une <em>instance</em> de
message, et non un simple objet obtenu avec <code>JSON.parse</code>.
Cela est nécessaire pour récupérer les informations telles que le type
de message, et l’accès aux méthodes offertes par la classe
correspondante. Il vous faudra donc réfléchir aux informations que vous
inclurez dans le JSON, et à la manière de décoder un JSON en une
instance de la bonne classe.</p>
<p>Notez également qu’un problème similaire se posera avec certaines
sous-classes de <code>Message</code>, par exemple
<code>SetPlayerMessage</code> et <code>UpdateMapMessage</code>. Ces deux
messages offrent des méthodes qui doivent retourner des instances de
classes telles que <code>PlayerInfo</code> ou <code>GameMap</code>, et
non de simples objets. Si j’encode un message de type
<code>SetPlayerMessage</code> puis le décode, je dois donc pouvoir
appeler <code>getPlayer()</code> sur la valeur retournée et obtenir une
instance de <code>PlayerInfo</code>, puis appeler
<code>getShape()</code> sur celle-ci pour obtenir une instance de
<code>Shape</code>.</p>
<h3 id="affichage-1">Affichage</h3>
<p>Nous avons déjà parlé de la nécessité d’afficher les scores de chaque
player à côté du canvas. L’affichage doit par ailleurs être modifié ou
complété des deux manières suivantes. - À côté du canvas, l’id qui nous
a été assigné doit être affiché clairement (par exemple,
<code>"You are player &lt;id&gt;"</code>). Une nouvelle méthode
<code>setPlayerId</code> a été ajoutée au renderer pour l’informer de
l’id qui lui a été assigné, tel que fourni par le message
<code>JoinMessage</code> du serveur. - L’affichage des pièces tombantes
doit être tel que les pièces qui appartiennent à d’autres joueurs soient
partiellement transparentes, et affichées <em>sous</em> la notre. Afin
de faciliter l’affichage conditionnellement transparent des pièces, nous
avons modifié le tableau <code>shapeColors</code> dans
<code>constants.js</code> pour que la composante alpha de la valeur
<code>rgba</code> de chaque élément soit <code>x</code>, et non plus
<code>1</code>. Ceci devrait vous permettre d’utiliser une Regexp pour
modifier la transparence des pièces en fonction de l’id auquel elles
appartiennent.</p>
<p>Nous mentionnons ici que la couleur associée à un joueur peut être
choisie arbitrairement, mais doit être la même sur tous les clients : si
mes pièces m’apparaissent rouge, alors elles doivent apparaitre rouge
chez les autres aussi.</p>
<h2 id="game-over">Game Over</h2>
<p>Lorsqu’une partie se termine (parce que le board est trop plein pour
permettre à une nouvelle pièce d’être créée, comme nous l’avons vu dans
le précédent labo), le serveur doit en notifier les clients, et ceux-ci
doivent afficher un popup donnant l’id de la personne qui a gagné, ainsi
que son score, ou bien un message pertinent en cas d’égalité. La méthode
<code>gameOver</code> de <code>Replica</code> est responsable de
ceci.</p>
<p>Du côté du serveur, celui-ci doit réinitialiser ses données,
c’est-à-dire ses joueurs et la carte. Nous vous demandons d’ailleurs,
dans ce but, de compléter l’implémentation de la méthode
<code>clear</code> de <code>GameMap</code>.</p>
<h2 id="tests">Tests</h2>
<p>Les tests vous sont fournis pour ce labo. Nous en avons ajouté pour
les nouvelles fonctionnalités, et en avons modifié certains pour tester
également que les messages envoyés sont cohérents. Par exemple, nous
vérifions que des messages <code>SetPlayerMessage</code> sont bien
envoyés par <code>Game</code> à l’appel de <code>step()</code> pour
chaque pièce du jeu qui a pu descendre d’une case.</p>
<p>Comme pour les labos précédents, nous vous encourageons à compléter
nos tests avec les vôtres si vous le souhaitez. Nous vous demandons
simplement de ne pas modifier ceux que nous vous fournissons.</p>
<h1 id="installation-et-lancement">Installation et lancement</h1>
<p>Les mêmes instructions que pour le labo précédent sont valables ici.
Exécutez <code>npm install</code> pour installer toutes les dépendances
du projet, et utilisez les différentes commandes (<code>start</code>,
<code>watch</code> et <code>test</code>) définies dans
<code>package.json</code> pour exécuter et tester votre code.</p>
<h1 id="travail-à-réaliser">Travail à réaliser</h1>
<p>Il vous est demandé d’implémenter tout ce qui a été décrit dans ce
document. Notez que les <code>TODO</code> présents dans la donnée ne
sont pas exhaustifs par rapport à ce qui vous est demandé. Par exemple,
c’est à vous de déterminer où et quand envoyer des messages aux clients,
et lesquels.</p>
</main>
</body>
</html>
