<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Typescript</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/white.css"
      id="theme"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/zenburn.min.css"
    />

    <link rel="stylesheet" href="./fontawesome-6.2.0/css/all.min.css" />
    <link rel="stylesheet" href="./style.css" />

    <script src="print.js"></script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <section data-background="#333333">
            <h2>Web</h2>
            <h1>Typescript</h1>
          </section>
          <section data-markdown>
            <textarea data-template>
                            ## Overview of Today's Class

                            - What is Typescript?
                            - Typescript types
                            - Type aliasing
                            - Type unions
                            - Type assertions
                            - Functions
                            - Generics
            </textarea>
          </section>
        </section>

        <!-- <section>
                    <section data-background="#333333" style="font-size: 0.8em;">
                        <h2>Retour évaluation du cours</h2>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## Cours

                            - Contenu
                                - Parfois "scolaire" (e.g. HTML), bénéficierait de plus d'interactivité
                                - Sécurité : l'ajout a été apprécié. À noter que du contenu était déjà prévu, simplement moins complet.
                                - Pas de typescript ? Si, aujoud'hui même. Ajouté ce semestre, d'où tard dans le cours ; sera donné plus tôt l'année prochaine.
                            - Les slides 2D parfois pénibles

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## Labos

                            - Trop de labos, pas assez de temps
                                - Discussions déjà en cours pour changer ça l'année prochaine.
                                - Solutions possibles :
                                    - Moins de labos mais plus gros, englobant plusieurs thèmes
                                    - Même nombre de labos, mais vous pouvez en skip x (e.g. 2) de votre choix.
                            - Trop de labos trop guidés
                                - Solution possible : ajout de labos plus libres (style labo final)

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## Tests

                            - Pas de tests papiers, yay !
                            - Formats un peu trop "BA1"
                                - Pas certain de comprendre. Trop de questions de cours ? Trop spécifiques ? Trop pièges ?
                            - Formats trop changeants
                                - On a effectivement changé de format pour le Test 2, suite à vos remarques. Ça n'a malheureusement pas plu non plus. Ça permettra d'avoir un Test 3 plus adapté.
                                - Ceci dit, je ne pense pas que ça ait été pénalisant pour vos résultats.
                            - TEs n'évaluent pas vos compétences de dev
                                - C'est vrai ; ils testent votre compréhension, et donc inévitablement des détails de fonctionnement.

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## Plus généralement

                            - Les outils (github classroom, le site, les tests)
                                - Classroom, Discussions, Tests appréciés (sauf le VPN...)
                            - Un cours plus pertinent en deuxième année

                        </textarea>
                    </section>
                    <section data-markdown style="font-size: 0.8em;">
                        <textarea data-template>
                            ## Questions ou remarques ?

                            Je note tout ; une discussion est prévue avec le responsable de la fiche unité et les prochains enseignants du cours. J'y partagerai vos remarques.

                        </textarea>
                    </section>
                </section>                     -->

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>What is Typescript?</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Typescript

                            Typescript:
                            - is a superset of JavaScript (i.e. JS is TS, but TS is not JS)
                            - adds static typing to JavaScript, allowing compile time type checking
                            - compiles (transpiles) to JavaScript

                            <div class="detail">

                            https://www.typescriptlang.org/

                            </div>
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Compiling Typescript

                            **Source-to-source compilation** : `tsc` compiles typescript to JavaScript.

                            ```bash
                            npm install -g typescript
                            tsc hello.ts
                            ```

                            - Compilation does type checking and removes TypeScript's type annotations.
                            - Can target older versions of JS (e.g. ES12 with `--target es2021`).
                                - By default, targets ES5 (ES2015).
                            - Flags can control how strict the compiler is.

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Exploring Typescript

                            - [Typescript playground](https://www.typescriptlang.org/play/)
                            - [Solving Typescript Errors](https://www.totaltypescript.com/tutorials/solving-typescript-errors/errors/fixing-x-is-not-assignable-to-y/exercise)
                            - [Typescript Exercises](https://typescript-exercises.github.io/#exercise=4&file=%2Findex.ts)

            </textarea>
          </section>
        </section>

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Typescript Types</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Primitive types

                            - `number`
                            - `string`
                            - `boolean`
                            - `null`
                            - `undefined`

                            We will see more about `null` and `undefined` values later; they are special.

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Type annotation

                            Typescript can infer types from the code, but it is better to annotate them explicitly.

                            ```typescript
                            let x = 42; // x is inferred to be of type number
                            let y: number = 42; // y is explicitly of type number
                            let z: number; // z is explicitly of type number

                            x = 42; // OK
                            // x = "42"; // Error
                            ```

                            Function arguments and return values can also be inferred or annotated.

                            ```typescript
                            window.onmousedown = function (mouseEvent) {
                                // Type of mouseEvent inferred to match type of onmousedown
                            };

                            function add(x: number, y: number): number { /* ... */ }
                            ```
                            It is recommended to use explicit type annotations (especially for variables without an initial value).
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Object types

                            The type of an object is the set of its properties and their types.

                            ```typescript
                            let obj: { name: string, age: number } = { name: "John", age: 42 };
                            ```

                            Any object with those properties and types is of this type.

                            ```typescript
                            let obj = { name: "John", age: 42 };
                            let obj2 = { name: "John", age: 42, city: "Paris" };
                            // Both are of type { name: string, age: number }

                            let obj3: { name: string, age: number } = { name: "John", age: "42"};
                            // Error: age is not a number
                            ```

                            Typescript uses a structural type system, i.e. two objects are of the same type if they have the same structure.

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Any type

                            `any` is a special "root" type that can be any value.

                            ```typescript
                            let x: any;
                            x = 42; // OK
                            x = "42"; // OK
                            x = { name: "John", age: 42 }; // OK
                            ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## `void` type

                            `void` is the type of functions that return nothing.

                            ```typescript
                            function log(message: string): void {
                                console.log(message);
                            }
                            ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.65em">
            <textarea data-template>
                            ## Null and undefined

                            The option `--strictNullChecks` defines the behaviour of Typescript with regards to `null` and `undefined` variables.

                            When it is enabled, `null` and `undefined` have their own types, and can thus only be assigned to variables of type `null` or `undefined`.

                            ```typescript
                            let x: number;
                            x = null; // Error
                            let y: any;
                            y = null; // OK
                            let z: null;
                            z = null; // OK
                            ```

                            With `--strictNullChecks` disabled, `null` and `undefined` can be assigned to a property of any type, like in JS.

                            ```typescript
                            let x: number;
                            x = null; // OK
                            ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Array type

                            Arrays are generic types. We will see generics later.

                            In Typescript, all elements of an array must have the same type.

                            ```typescript
                            let x: number[];      // Shorthand notation
                            let y: Array<number>; // Explicit generics notation

                            x = [1, 2, 3]; // OK
                            x = [1, 2, "3"]; // Error
                            x = ["1", "2", "3"]; // Error
                            ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Tuple type

              A tuple is an array with a fixed number of elements of potentially different types.

              A pair is a Tuple of two elements, a triplet is Tuple of three elements, etc...
              ```typescript
              let x: [string, number];
              x = ["John", 42]; // OK
              x = [42, "John"]; // Error
              ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Literal types (wat?!)

                            Types can be literals in Typescript.

                            ```typescript
                            let x: 42;
                            x = 42; // OK
                            x = 43; // Error
                            ```

                            Why?! We'll see...

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Function types

                            The type of a function is the type of its parameters and its return value.

                            ```typescript
                            function add(x: number, y: number): number {
                                return x + y;
                            }
                            // Type : (x: number, y: number) => number
                            ```

                            Note : the argument names are only for documentation purposes.
                            ```typescript
                            let add: (x: number, y: number) => number;

                            add = function (a: number, b: number): number {
                                return a + b;
                            } // OK, even though argument names (not types!) don't match
                            ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.65em">
            <textarea data-template>
              ## Never type

              `never` is the type of values that never occur. It is a type that will never hold a value.

              For example, a function that never returns.

              ```typescript
              function error(message: string): never {
                  throw new Error(message);
              }
              ```

              We will come back to this type in a bit...
              
            </textarea>
          </section>
        </section>

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Type aliasing</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Type aliasing

                Types can be aliased with the `type` keyword.

                ```typescript
                type Uid = string; // simple type aliasing

                // aliasing for object types, Person type is a named alias
                // for the anonymous type {id: Uid, name: string, age: number}
                type Person = {
                    id: Uid,
                    name: string,
                    age: number
                };

                let john: Person;
                john = { id: "490028839", name: "John", age: 42 }; // OK
                ```
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Interfaces

                Interfaces are a special kind of type alias for objects.

                ```typescript
                interface Point {
                    x: number;
                    y: number;
                };
                ```

                One difference is that more properties can be added later on.

                ```typescript
                interface Point {
                    z: number;
                } // Point now has 3 properties : x, y, z
                ```

                Another difference is that interfaces can be extended.

                ```typescript
                interface Point3D extends Point {
                    z: number
                }; // Point3D has 3 properties : x, y, z
                ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Type aliasing vs interfaces

              Type Aliases and Interfaces (recap)

              - Type aliases and interfaces are very similar, and in many cases you can choose between them freely.
              - Almost all features of an interface are available in type.
              - One key distinction is that we can add new properties to an interface but not a type alias.
              - The other is that we can extend an interface using `extends`.

              <div style="float:left;">

              ```typescript
              interface Vehicle {
                color: string;
              }

              interface Vehicle {
                topSpeed: number;
              }
              let car: Vehicle = {color: "Green", topSpeed: 25};
              ```

              </div>

              <div style="float:left; margin-left: 5px">

              ```typescript
              type Vehicle = {
                color: string;
              }

              type Vehicle = {
                topSpeed: number;
              }
              // Error: Duplicate identifier 'Vehicle'.
              ```

              </div>

            </textarea>
          </section>
        </section>

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Type unions and intersections</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Type Unions

                In language theory, a union type is the type of a value that can be of several types.

                ```typescript
                let x: string | number;
                x = "John"; // OK
                x = 42; // OK
                x = true; // Error
                ```

                Why?

                ```typescript
                type Uid = string | number;
                type LockState = "locked" | "unlocked";
                type PositiveOddNumberUnderTen = 1 | 3 | 5 | 7 | 9;

                function printDouble(x: number | string) {
                    console.log(x + x);
                }
                ```

                <div class="detail">

                (Hence the relevance of literal types)

                </div>


            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Narrowing
              
              When using a union type, only the properties and methods that are common to all types in the union can be used.

              ```typescript
              function append(str: string, suffix: string | number) {
                console.log(str + suffix); // OK because '+' is defined for both string and number
                // console.log(str + suffix.toUpperCase()); // Error: 'toUpperCase' is not defined for number
              }
              ```

              Similarly, recall that, when `--strictNullChecks` is enabled, `null` and `undefined` are their own types, so `string | null` cannot be used as a string.
              
              ```typescript
              function toUpperCase(str: string | null) {
                console.log("Hello, " + str.toUpperCase()); // error 'str' is possibly null
              }
              ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Narrowing
                              
                            Typescript can understand some `if` statements to narrow the type of a variable.

                            ```typescript
                            function uppercaseAppend(str: string, suffix: string | number) {
                                if (typeof suffix === "string") {
                                    // suffix has type string in this branch
                                    console.log(str + suffix.toUpperCase());
                                } else {
                                    // suffix has type number in this branch
                                    console.log(str + suffix);
                                }
                            }
                            ```

                            Or in the example of `string | null`:
                            
                            ```typescript
                            function toUpperCase(str: string | null) {
                              if (str !== null) {
                                // str has type string in this branch
                                console.log("Hello, " + str.toUpperCase()); // OK
                              }
                            }
                            ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Narrowing with the `in` operator

                Another way to narrow a type is depending on the presence of a property.

                ```typescript
                type Fish = { swim: () => void };
                type Bird = { fly: () => void };
                type Human = { walk: () => void; swim: () => void };

                type Animal = Fish | Bird | Human;

                function move(animal: Animal) {
                    if ("swim" in animal) {
                        // animal has type Fish | Human in this branch
                        return animal.swim();
                    }
                    return animal.fly();
                }
                ```

            </textarea>
          </section>

          <section data-markdown style="font-size: 0.6em">
            <textarea data-template>
              ## Intersection types

              An intersection type is a type that combines multiple types into one using `&`.

              This allows us to build more complex types from simple reusable ones.

              Given two simple types, `Person` and `Address`
              ```ts
              type Person = {
                name: string;
                age: number;
              }

              type Address = {
                street: string;
                city: string;
                country: string;
              }
              ```
              We can combine them into a new type `PersonWithAddress` using an intersection type:
              ```ts
              type PersonWithAddress = Person & Address;

              const user: PersonWithAddress = {
                name: "Alice",
                age: 30,
                street: "Espl. des Particules 1",
                city: "Genève",
                country: "Switzerland"
              };

              console.log(`${user.name} lives in ${user.city}, ${user.country}.`);
              ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.6em">
            <textarea data-template>
              ## Never type with unions and intersections

              Recall that `never` is the type of values that never occur.

              Because empty intersections cannot have values, they are also of type `never`:
              ```typescript
              type Alphanumeric = string & number; // never as we can't have a value that is both a string and a number
              ```

              Since no type can be assigned to `never`, it can also be used to have exhaustive checking in a match statement:
              ```typescript
              type Role = 'admin' | 'user'; // (union type, more on this later)

              const authorize = (role: Role): string => {
                switch (role) {
                  case 'admin':
                    return 'You can do anything';
                  case 'user':
                    return 'You can do some things';
                  default:
                    // unreachable code, until we add a new role
                    const _unreachable: never = role; // cannot assign to never -> compile error
                    throw new Error(`Invalid role: ${_unreachable}`);
                }
              };
              ```
            </textarea>
          </section>
        </section>

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Functions</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Optional arguments

                We can make arguments optional by adding a `?` after their name. They must come after all required arguments.

                ```typescript
                function f(x?: number) {
                    // x actually has type number | undefined
                    // ...
                }
                f(); // OK, x is undefined
                f(10); // OK
                ```

                Otherwise, a default value can be given in addition to that argument's type.

                ```typescript
                function f(x: number = 10) {
                    // x has type number
                    // ...
                }
                ```
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.7em">
            <textarea data-template>
                ## Function overloading

                Typescript allows multiple functions with the same name but different (overloaded) signatures.

                ```typescript
                function makeDate(timestamp: number): Date;               // Overload 1
                function makeDate(m: number, d: number, y: number): Date; // Overload 2
                function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { // Implementation
                    // Arguments are union types of the corresponding arguments in the overloads
                    if (d !== undefined && y !== undefined) {
                        return new Date(y, mOrTimestamp, d);
                    } else {
                        return new Date(mOrTimestamp);
                    }
                }
                ```

                Overloaded functions are defined by declaring:
                - A list of overloaded signatures, each with different arguments and return type, and no body.
                - A single implementation signature, with each argument being a union (`number | undefined`) of the corresponding arguments in the overloaded signatures.
                - The function implementation, using the implementation signature's arguments.
                - Note that the function implementation cannot be called directly (e.g. it is not possible to call `makeDate(1, 2)`).

            </textarea>
          </section>
        </section>
        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Type assertions</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Type assertions - the `as` keyword

                Typescript can't always infer the type of a variable.

                We can use a *type assertion*, with the `as` keyword, to specify a more (or less) specific type:

                ```typescript
                // getElementById returns HTMLElement | null;
                // If we know that it cannot be null and it is a canvas element,
                // we narrow the union, and type-assert down
                const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement; // more specific type
                ```

                We can also type-assert up (i.e. tell Typescript that a variable is of a more general type, e.g. `Element`).

                However, we may not type-assert to an impossible type.

                ```typescript
                let x = "hello" as number; // Error
                ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Non-null assertions

                If a value's type is a union with `null` and/or `undefined`, we can tell Typescript that the value is not null or undefined with the `'!'` postfix.

                ```typescript
                // x?: number -> x is an optional parameter. x could be undefined
                function liveDangerously(x?: number | null) {
                    // Pretend x is a number:
                    console.log(x!.toFixed());

                    // Equivalent to:
                    // console.log((x as number).toFixed());
                }
                ```

            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                ## Type assertions are static

                Type assertions only tell the compiler what type a value has. The compiler will then use that type to type-check the code.

                **Recall**: because Typescript is only a static type checker, type assertions are removed during compile time and have no effect at runtime.

            </textarea>
          </section>
        </section>
        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Generics</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Generics
              When writing software, we often want to write reusable code that can work with a variety of types rather than a single one.

              For example if we want to write a function that returns the first element of an array:
              ```typescript
              function firstElement(arr: number[]): number | undefined {
                return arr[0];
              }
              ```
              This function only works with arrays of numbers. If we want to use it with arrays of strings, we would have to write a new function or use union types.
              ```typescript
              function firstElement(arr: number[] | string[]): number | string | undefined {
                return arr[0];
              }
              ```
              But it quickly becomes unmanageable if we want to use it with arrays of other types.
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Generic functions

              To solve this we can use generic functions, which are functions that can have type parameters.

              In the example below, `Type` is a type parameter that can be replaced with any type when the function is called.
              ```typescript
              function firstElement<Type>(arr: Type[]): Type | undefined {
                  return arr[0];
              }
              let x = firstElement<number>([1,2,3,4]) // x is of type number | undefined
              ```

              The type parameter can be constrained in many ways. One example:

              ```typescript
              function longest<Type extends { length: number }>(a: Type, b: Type) {
                  if (a.length >= b.length) {
                      return a;
                  } else {
                      return b;
                  }
              }
              ```
            </textarea>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
              ## Generic interfaces

              Interfaces can have type parameters.

              ```typescript
              interface Container<T> {
                value: T;
              }

              const stringContainer: Container<string> = {
                value: "Hello, world!"
              };
              ```

              Or more complex :
              ```typescript
              interface BinaryTree<T> {
                  value: T;
                  left: BinaryTree<T> | null;
                  right: BinaryTree<T> | null;
                  getSmallest(): T;
              }

              let a: BinaryTree<number>;
              ```

            </textarea>
          </section>
        </section>

        <section>
          <section data-background="#333333" style="font-size: 0.8em">
            <h2>Hands on!</h2>
          </section>
          <section data-markdown style="font-size: 0.8em">
            <textarea data-template>
                            ## Get used to Typescript

                            Do the first few exercises of [Typescript exercises](https://typescript-exercises.github.io/#exercise=1&file=%2Findex.ts).

                            Go through the questions of [w3schools' quiz](https://www.w3schools.com/typescript/exercise.php?filename=exercise_simple_types2).

            </textarea>
          </section>
        </section>
      </div>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.js"></script>
    <script src="./script.js" type="module"></script>
  </body>
</html>
